"""
                                                ▶ 4.1 수동으로 이터레이터 소비◀ 
♣  문제 :  순환 가능한아이템에 접근할 때 for 순환문을 사용하고 싶지 않다면?
        
↘  해결 : 수동으로 이터레이터를 소비하려면 next() 함수를 사용하고 StopIteration예외를 처리하기 위한
           코드를 직접 작성한다. 



 """

print('###############################################################################')
print('########################################## 4.1 수동으로 이터레이터 소비#####################################')
print('###############################################################################')


#파일의 줄을 읽어오는 코드를 예로 들어보자

with open('d:/data/emp2.csv') as f:
    try:
        while True:
            line = next(f)
            print(line, end='')
    except StopIteration:
        print('다 소비했습니다.')
        pass


# 일반적으로 Stopiteration 은 순환의 끝을 알리는데 사용한다.
# 하지만 next() 를 수동으로 사용한다면 None과 같은 종료 값을 반환하는데 사용할 수도 있다.


with open('d:/data/emp2.csv') as f:
    while True:
        line = next(f, None)
        if line is None:
            break
        print(line, end='')

# 대개의 경우, 순환 for문을 사용하지만 보다 더 정교한 조절이 필요할 때도 있다.
# 기저에서 어떤 동작이 일어나는지 정확히 알아둘 필요가 있다.
# 다음 상호작용을 하는 예제를 통해 순환하는 동안 기본적으로 어떤 일이 일어나는지 보자.

itmes = [1,2,3]
# 이터레이터 열기
it = iter(itmes)        # items.__iter__()실행
# 이터레이터 실행
print(next(it))               #it.__next__()실행      1
print(next(it))               #it.__next__()실행      2
print(next(it))               #it.__next__()실행      3
# print(next(it))               #Error StopIteration

#다음 장에서는 순환 기술과, 기본 이터레이터 프로토콜이 소비되는 방법을 자세히 알아본다









"""
                                                ▶ 4.2 델리게이팅 순환◀ 
♣  문제 :  리스트, 튜플 등 순환 가능한 객체를 담은 사용자 정의 컨테이너를 만들었다. 
            이 컨테이너 안에 사용 가능한 이터레이터를 만들고 싶다.

↘  해결 :  일반적으로 컨테이너 순환에 사용할 __iter__() 메소드만 정의해주면 된다. 
            


 """

print('###############################################################################')
print('########################################## 4.2 델리게이팅 순환#####################################')
print('###############################################################################')



class Node:
    def __init__(self,value):
        self.value = value
        self._children = []
    def __repr__(self):
        return 'Node({!r})'.format(self.value)
    def add_child(self,node):
        print('리스트에 추가합니다.')
        self._children.append(node)
    def __iter__(self):
        return iter(self._children)

if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child2 = Node(2)
    root.add_child(child1)
    root.add_child(child2)
    child1.add_child(root)
    child1.add_child((child2))
    # for ch in root:
    #     print(ch)
    for ch in child1:
        print(ch)
#
# 파이썬의 이터레이터 프로토콜은 __iter__() 가 실제 순환을 수행하기 위한 __next__() 메소드를
# 구현하는 특별 이터레이터 객체를 반환하기를 요구한다.
# 만일 다른 컨테이너에 들어있는 내용물에 대한 순환이 해야할 작업의 전부라면이터레이터 동작 방식을 완전 이해할 필요는 없다/
# iter() 함수에 대한 사용은 코드를 깔끔하게 하는 지름길과 같다.
# iter(s)는 단순히 s.__iter__()를 호출해서 이터레이터를 반환하는데, 이는 len(s)가 s.__len__()을 호출하는 것과 같은 방식이다.
# 아주효율적이라는거..?











"""
                                                ▶ 4.3 제너레이터로 새로운 순환 패턴 생성◀ 
♣  문제 :  내장함수 ( range(),  reversed()  ) 와는 다른 동작을 하는 순환 패턴을 만들고 싶다.
            새로운 순환 패턴을 만들고 싶다면,, 제너레이터 함수를 사용해서 정의해야 한다.
            특정 범위의 부동 소수점 숫자를 만드는 제너레이터 코드르 보라.

↘  해결 :   



 """

print('###############################################################################')
print('########################################## 4.3제너레이터로 새로운 순환 패터 생성#####################################')
print('###############################################################################')

# 특정 범위의 부동 소수점 숫자 만드는 제너레이터 코드
def frange(start, stop, increment):
    x = start
    while x < stop:
        yield x
        x += increment

#위와 같은 함수를 사용하려면, for 순환문이나 순환 객체를 소비하는 다른 함수 등을 사용한 순환을 해야 한다.

for n in frange(0,4,0.5):
    print(n)

print(list(frange(0, 1, 0.125)))    #[0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875]

#내부의 yield 문의 존재로 인해 함수가 제너레이터가 되었다.
# 일반 함수와는 다르게 제너레이터는 순환에 응답하기 위해 실행 된다.
# 이런 함수가 어떻게 동작하는지 다음 예를 본다.


def countdown(n):
    print('Starting to count from', n)
    while n > 0:
        yield n
        n -= 1
    print('Done!')

c = countdown(3)
print(c)   #<generator object countdown at 0x02EB81E0>

print(next(c))
print(next(c))
print(next(c))

# 중요한 점은 제너레이터 함수가 순환에 의한 [다음] 연산에 응답하기 위해서만 된다는 점이다.
# 제너레이터 함수가 반환되면 순환을 종료한다.
# 하지만, 일반적으로 순환에 사용하는 for 문이 상세 내역을 책임지기 때문에
# 우리가 직접적으로 신경쓰지 않아도 된다.




